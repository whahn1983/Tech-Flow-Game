<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta http-equiv="Content-Security-Policy" content="default-src 'self'; script-src 'self' 'unsafe-inline'; style-src 'self' 'unsafe-inline'; img-src 'self' data: blob:; media-src 'self'; connect-src 'self'; worker-src 'self'" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover" />
  <meta name="theme-color" content="#0a1330" />
  <meta name="mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
  <meta name="apple-mobile-web-app-title" content="Tech Runner" />
  <link rel="icon" href="favicon.svg" type="image/svg+xml" />
  <link rel="apple-touch-icon" href="apple-touch-icon.png" />
  <link rel="manifest" href="/manifest.json" />
  <title>Tech Flow Runner</title>
  <style>
    :root {
      --bg-top: #0a1330;
      --bg-bottom: #050910;
      --neon: #2ef8ff;
      --accent: #8e5cff;
      --ground: #16233f;
      --text: #e9f6ff;
    }
    * { box-sizing: border-box; }
    html, body, * {
      -webkit-user-select: none;
      user-select: none;
      -webkit-touch-callout: none;
      -webkit-tap-highlight-color: transparent;
    }
    html {
      background-color: #0a1330;
    }
    body {
      margin: 0;
      min-height: 100vh;
      font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
      color: var(--text);
      background: radial-gradient(circle at 15% 10%, #1b2e5f, var(--bg-top) 45%, var(--bg-bottom));
      display: grid;
      place-items: center;
      overflow-x: hidden;
      overflow-y: auto;
    }
    .wrap {
      width: min(96vw, 900px);
      text-align: center;
    }
    h1 {
      margin: 0 0 10px;
      color: var(--neon);
      text-shadow: 0 0 12px rgba(46, 248, 255, 0.6);
      letter-spacing: 0.8px;
    }
    .hud {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 10px;
      margin-bottom: 10px;
      font-weight: 700;
    }
    .chip {
      padding: 10px;
      border-radius: 12px;
      border: 1px solid rgba(255,255,255,0.2);
      background: rgba(255,255,255,0.08);
      backdrop-filter: blur(4px);
    }
    canvas {
      width: 100%;
      height: auto;
      border-radius: 14px;
      border: 2px solid rgba(46, 248, 255, 0.35);
      box-shadow: 0 0 26px rgba(46, 248, 255, 0.25);
      background: linear-gradient(180deg, #111f45 0%, #0a1020 70%);
    }
    /* Desktop fullscreen: expand game to fill the viewport */
    body.game-fullscreen {
      overflow: hidden;
      align-items: stretch;
    }
    body.game-fullscreen h1,
    body.game-fullscreen .controls,
    body.game-fullscreen .button-row,
    body.game-fullscreen .leaderboard-panel {
      display: none !important;
    }
    body.game-fullscreen .wrap {
      width: 100vw;
      max-width: 100vw;
      display: flex;
      flex-direction: column;
    }
    body.game-fullscreen #canvasWrapper {
      flex: 1;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    body.game-fullscreen #fullscreenBtn {
      position: fixed;
    }
    body.game-fullscreen .hud {
      margin-bottom: 4px;
    }
    body.game-fullscreen canvas {
      width: min(100vw, calc((100vh - 64px) * 900 / 420));
      max-height: calc(100vh - 64px);
      height: auto;
      border-radius: 0;
    }
    .controls {
      margin-top: 10px;
      opacity: 0.9;
    }
    .button-row {
      display: inline-flex;
      gap: 10px;
      flex-wrap: wrap;
      justify-content: center;
    }
    .leaderboard-panel {
      margin-top: 14px;
      padding: 14px;
      border-radius: 12px;
      border: 1px solid rgba(255,255,255,0.2);
      background: rgba(255,255,255,0.08);
      text-align: left;
    }
    .leaderboard-panel h2 {
      margin: 0 0 10px;
      font-size: 1.1rem;
      color: var(--neon);
    }
    .leaderboard-form {
      display: grid;
      grid-template-columns: 1fr auto;
      gap: 8px;
      margin-bottom: 10px;
    }
    .leaderboard-form input {
      border-radius: 8px;
      border: 1px solid rgba(255,255,255,0.35);
      padding: 8px 10px;
      background: rgba(5, 9, 16, 0.4);
      color: var(--text);
      font-weight: 600;
    }
    .leaderboard-form button {
      margin-top: 0;
      padding: 8px 14px;
    }
    .leaderboard-note {
      margin: 0 0 10px;
      opacity: 0.85;
      font-size: 0.92rem;
    }
    .leaderboard-list {
      margin: 0;
      padding-left: 20px;
      max-height: 250px;
      overflow-y: auto;
      scrollbar-width: thin;
      scrollbar-color: rgba(255,255,255,0.25) transparent;
    }
    .leaderboard-list::-webkit-scrollbar {
      width: 6px;
    }
    .leaderboard-list::-webkit-scrollbar-track {
      background: transparent;
    }
    .leaderboard-list::-webkit-scrollbar-thumb {
      background: rgba(255,255,255,0.25);
      border-radius: 3px;
    }
    .leaderboard-list li {
      margin: 4px 0;
    }
    button {
      margin-top: 12px;
      border: 0;
      border-radius: 999px;
      padding: 10px 18px;
      font-weight: 700;
      color: #071425;
      background: linear-gradient(115deg, var(--neon), #75ffd4);
      cursor: pointer;
    }
    #installBtn {
      display: none;
      background: linear-gradient(115deg, var(--accent), #c084fc);
    }
    #fullscreenBtn {
      display: none;
      position: absolute;
      bottom: 10px;
      right: 10px;
      width: 34px;
      height: 34px;
      padding: 7px;
      margin-top: 0;
      border-radius: 6px;
      background: rgba(5, 9, 16, 0.55);
      border: 1px solid rgba(46, 248, 255, 0.3);
      color: rgba(46, 248, 255, 0.85);
      line-height: 0;
      z-index: 10;
      transition: background 0.15s, color 0.15s;
    }
    #fullscreenBtn:hover {
      background: rgba(46, 248, 255, 0.15);
      color: #2ef8ff;
    }
    #fullscreenBtn[data-locked="true"] {
      background: rgba(46, 248, 255, 0.18);
      border-color: rgba(46, 248, 255, 0.7);
      color: #2ef8ff;
    }
    .touch-hint { display: none; }
    @media (pointer: coarse) {
      .keyboard-hint { display: none; }
      .touch-hint { display: inline; }
    }
    #canvasWrapper {
      position: relative;
      display: block;
    }
    #gameOverOverlay {
      position: absolute;
      left: 0;
      right: 0;
      top: 68%;
      display: none;
      justify-content: center;
      gap: 10px;
      pointer-events: none;
    }
    #gameOverOverlay.active {
      display: flex;
    }
    #gameOverOverlay button {
      pointer-events: auto;
      margin-top: 0;
    }
    #gameOverSubmitBtn {
      background: transparent;
      border: 2px solid var(--neon);
      color: var(--neon);
    }
    @media (max-width: 640px) {
      body {
        align-items: start;
        padding: 10px 0 28px;
        padding-top: max(10px, env(safe-area-inset-top));
        padding-bottom: max(28px, env(safe-area-inset-bottom));
      }
      h1 {
        font-size: 1.3rem;
        margin-bottom: 8px;
      }
      .hud {
        gap: 6px;
        margin-bottom: 8px;
      }
      .chip {
        padding: 7px 6px;
        font-size: 0.85rem;
      }
      .controls {
        font-size: 0.85rem;
        margin-top: 8px;
      }
      button {
        padding: 9px 14px;
        font-size: 0.9rem;
        margin-top: 8px;
      }
      .leaderboard-panel {
        margin-top: 10px;
        padding: 12px;
      }
      .leaderboard-form {
        grid-template-columns: 1fr;
      }
      .leaderboard-form button {
        margin-top: 0;
        width: 100%;
      }
    }
    /* Start overlay ‚Äî shown on first load */
    #startOverlay {
      position: absolute;
      inset: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      gap: 12px;
      pointer-events: none;
      z-index: 5;
    }
    #startOverlay.hidden {
      display: none;
    }
    #startBtn {
      font-size: 1.4rem;
      padding: 16px 44px;
      margin-top: 0;
      pointer-events: auto;
      box-shadow: 0 0 32px rgba(46, 248, 255, 0.55);
      letter-spacing: 0.5px;
    }
    #startHint {
      font-size: 0.9rem;
      opacity: 0.7;
      color: var(--text);
      pointer-events: none;
    }
    /* Score submission modal */
    .score-modal-overlay {
      position: fixed;
      inset: 0;
      background: rgba(5, 9, 16, 0.85);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 100;
      backdrop-filter: blur(4px);
    }
    .score-modal-overlay[hidden] {
      display: none;
    }
    .score-modal-box {
      background: linear-gradient(160deg, #0d1d42, #070f22);
      border: 1px solid rgba(46, 248, 255, 0.4);
      border-radius: 16px;
      padding: 28px 32px;
      max-width: 380px;
      width: 90vw;
      text-align: center;
      box-shadow: 0 0 40px rgba(46, 248, 255, 0.18);
    }
    .score-modal-box h2 {
      margin: 0 0 4px;
      color: var(--neon);
      font-size: 1.6rem;
    }
    .score-modal-dist {
      font-size: 1.1rem;
      font-weight: 700;
      margin: 0 0 18px;
      opacity: 0.9;
    }
    .score-modal-box label {
      display: block;
      margin-bottom: 8px;
      font-size: 0.95rem;
      opacity: 0.85;
      text-align: left;
    }
    .score-modal-box input {
      width: 100%;
      border-radius: 8px;
      border: 1px solid rgba(255,255,255,0.35);
      padding: 10px 12px;
      background: rgba(5, 9, 16, 0.5);
      color: var(--text);
      font-size: 1rem;
      font-weight: 600;
      font-family: inherit;
      margin-bottom: 14px;
    }
    .score-modal-btns {
      display: flex;
      gap: 10px;
      justify-content: center;
      flex-wrap: wrap;
    }
    .score-modal-btns button {
      margin-top: 0;
    }
    .score-modal-skip {
      background: rgba(255,255,255,0.14);
      color: var(--text);
    }
    .score-modal-status {
      margin: 12px 0 0;
      font-size: 0.88rem;
      min-height: 1.2em;
      opacity: 0.85;
    }
  </style>
</head>
<body>
  <main class="wrap">
    <h1>üèÉ Tech Flow Runner</h1>
    <section class="hud">
      <div class="chip">Distance: <span id="score">0</span>m</div>
      <div class="chip">Speed: <span id="speed">1.0</span>x</div>
      <div class="chip">Best: <span id="best">0</span>m</div>
    </section>
    <div id="canvasWrapper">
      <canvas id="game" width="900" height="420" aria-label="Tech Flow jump runner"></canvas>
      <button id="fullscreenBtn" type="button" aria-label="Toggle full screen"></button>
      <div id="gameOverOverlay">
        <button id="gameOverRebootBtn" type="button">Reboot Run</button>
        <button id="gameOverSubmitBtn" type="button">Submit Score</button>
      </div>
      <div id="startOverlay">
        <button id="startBtn" type="button">&#9654; Start</button>
        <span id="startHint" class="keyboard-hint">Press <strong>Space</strong> to start</span>
        <span id="startHintTouch" class="touch-hint" style="font-size:0.9rem;opacity:0.7;color:var(--text)">Tap to start</span>
      </div>
    </div>
    <div class="controls">
      <span class="keyboard-hint">Double jump with <strong>Space</strong>, <strong>W</strong>, or <strong>‚Üë</strong>. Press <strong>R</strong> to restart.</span>
      <span class="touch-hint">Tap the game to double jump. Tap Reboot Run to restart or Submit Score to save to the leaderboard.</span>
    </div>
    <div class="button-row">
      <button id="musicBtn" type="button">Play Music</button>
      <button id="installBtn" type="button">Install App</button>
    </div>
    <section class="leaderboard-panel" aria-live="polite">
      <h2>üåç Global Leaderboard</h2>
      <p id="leaderboardStatus" class="leaderboard-note">Loading scores...</p>
      <ol id="leaderboardList" class="leaderboard-list"></ol>
    </section>
  </main>

  <!-- Score submission modal ‚Äî shown after each run ends -->
  <div id="scoreModal" class="score-modal-overlay" role="dialog" aria-modal="true" aria-labelledby="scoreModalTitle" hidden>
    <div class="score-modal-box">
      <h2 id="scoreModalTitle">Signal Lost</h2>
      <p id="scoreModalDist" class="score-modal-dist"></p>
      <label for="scoreModalName">Enter your name for the global leaderboard:</label>
      <input id="scoreModalName" type="text" maxlength="24" placeholder="Your name" autocomplete="off" />
      <div class="score-modal-btns">
        <button type="button" id="scoreModalSubmit">Save Score</button>
        <button type="button" id="scoreModalSkip" class="score-modal-skip">Skip</button>
      </div>
      <p id="scoreModalStatus" class="score-modal-status"></p>
    </div>
  </div>

  <audio id="bgm" src="Tech Flow.mp3" loop preload="auto"></audio>

  <script>
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const scoreEl = document.getElementById('score');
    const speedEl = document.getElementById('speed');
    const bestEl = document.getElementById('best');
    const music = document.getElementById('bgm');
    const musicBtn = document.getElementById('musicBtn');
    const gameOverOverlay = document.getElementById('gameOverOverlay');
    const leaderboardStatus = document.getElementById('leaderboardStatus');
    const leaderboardList = document.getElementById('leaderboardList');
    const leaderboardEndpoint = './leaderboard.php';
    const scoreModal = document.getElementById('scoreModal');
    const scoreModalDist = document.getElementById('scoreModalDist');
    const scoreModalName = document.getElementById('scoreModalName');
    const scoreModalSubmit = document.getElementById('scoreModalSubmit');
    const scoreModalSkip = document.getElementById('scoreModalSkip');
    const scoreModalStatus = document.getElementById('scoreModalStatus');
    const startOverlay = document.getElementById('startOverlay');
    const startBtn = document.getElementById('startBtn');

    let gameStarted = false;
    let score = 0;
    let best = Number(localStorage.getItem('techFlowRunnerBest') || 0);
    let speedMult = 1;
    let baseSpeed = 4.2;
    let gameOver = false;
    let groundOffset = 0;
    let sceneryOffset = 0;
    let spawnTimer = 0;
    let scheduledGapPx = 0;
    let worldOffset = 0;
    let latestRunScore = 0;
    let canSubmitScore = false;

    const gravity = 0.75;
    const player = {
      x: 120,
      y: 0,
      w: 48,
      h: 58,
      vy: 0,
      jumpPower: -14,
      onGround: true,
      jumpsLeft: 2
    };
    const baseGroundY = canvas.height - 72;
    const precipiceFloorY = canvas.height - 1;
    player.y = baseGroundY - player.h;

    const obstacles = [];
    const spawnActions = ['jump', 'stay'];
    const transitionFrameBudget = {
      start: { jump: 24, stay: 20 },
      jump: { jump: 22, stay: 44 },
      stay: { jump: 26, stay: 18 }
    };
    const courseSafety = {
      minTakeoffBuffer: 96,
      minTakeoffBufferForStay: 176,
      minLandingBuffer: 162,
      minLandingBufferForStay: 220,
      minCaveHeadroom: player.h + 14,
      minCaveHeadroomForJumpObstacle: 168,
      minCaveHeadroomForAnyObstacle: 112,
      jumpObstacleCaveApproachBuffer: 72,
      maxDownhillBeforeJumpObstacle: 34,
      maxDownhillAfterStayObstacle: 24,
      maxDownhillBeforeDrone: 36,
      maxDownhillBeforeDroneInCave: 22,
      stayObstacleRunoutDistance: 154,
      minJumpClearance: player.h + 138,
      clearanceSampleStep: 8,
      maxPrecipiceWidth: 136,
      precipiceAvoidanceBuffer: 80,
      obstacleSpacingBuffer: 28,
      minObstacleGapPx: {
        jump: { jump: 170, stay: 132 },
        stay: { jump: 140, stay: 116 }
      },
      minObstacleGapPxInCave: {
        jump: { jump: 230, stay: 168 },
        stay: { jump: 188, stay: 140 }
      }
    };

    function tryPlayMusic() {
      music.volume = 0.55;
      music.play().then(() => {
        musicBtn.textContent = 'Music On üéµ';
      }).catch(() => {
        musicBtn.textContent = 'Tap to Enable Music';
      });
    }

    musicBtn.addEventListener('click', () => {
      if (!music.paused) {
        music.pause();
        musicBtn.textContent = 'Play Music';
      } else {
        tryPlayMusic();
      }
    });


    document.getElementById('gameOverRebootBtn').addEventListener('click', resetGame);
    document.getElementById('gameOverSubmitBtn').addEventListener('click', openScoreModal);

    function setLeaderboardStatus(message) {
      leaderboardStatus.textContent = message;
    }

    function setScoreSubmissionState(isEnabled) {
      canSubmitScore = isEnabled;
      document.getElementById('gameOverSubmitBtn').disabled = !isEnabled;
    }

    function renderLeaderboard(entries) {
      leaderboardList.innerHTML = '';
      if (!entries.length) {
        const item = document.createElement('li');
        item.textContent = 'No scores yet. Be the first to upload a run!';
        leaderboardList.appendChild(item);
        return;
      }

      entries.forEach((entry, index) => {
        const item = document.createElement('li');
        item.textContent = `#${index + 1} ${entry.name} ‚Äî ${Math.floor(entry.score)}m`;
        leaderboardList.appendChild(item);
      });
    }

    async function fetchLeaderboard() {
      try {
        const response = await fetch(leaderboardEndpoint, { cache: 'no-store' });
        if (!response.ok) throw new Error('Could not load leaderboard');
        const payload = await response.json();
        renderLeaderboard(payload.entries || []);
        if (!gameStarted) {
          setLeaderboardStatus('Finish a run, then save your score to the global board.');
        }
      } catch {
        renderLeaderboard([]);
        setLeaderboardStatus('Global leaderboard unavailable. Ensure leaderboard.php is deployed and writable.');
      }
    }

    async function submitScore(name, runScore) {
      const response = await fetch(leaderboardEndpoint, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ name, score: runScore })
      });

      const payload = await response.json();
      if (!response.ok) {
        throw new Error(payload.error || 'Unable to save score.');
      }

      return payload.entries || [];
    }

    function openScoreModal() {
      if (!scoreModal.hidden) return;
      scoreModalStatus.textContent = '';
      scoreModalName.value = '';
      scoreModalDist.textContent = `Distance: ${latestRunScore}m`;
      scoreModalSubmit.disabled = false;
      scoreModal.hidden = false;
      scoreModalName.focus();
    }

    function closeScoreModal() {
      scoreModal.hidden = true;
    }

    scoreModalSkip.addEventListener('click', () => {
      closeScoreModal();
      setLeaderboardStatus(`Run ended at ${latestRunScore}m. Press R to reboot.`);
    });

    scoreModalSubmit.addEventListener('click', async () => {
      const name = scoreModalName.value.trim();
      if (!name) {
        scoreModalStatus.textContent = 'Please enter your name first.';
        return;
      }

      const scoreToSave = Math.floor(latestRunScore);
      scoreModalSubmit.disabled = true;
      scoreModalStatus.textContent = 'Saving your score...';

      try {
        const entries = await submitScore(name, scoreToSave);
        renderLeaderboard(entries);
        setLeaderboardStatus(`Saved ${scoreToSave}m for ${name}. Reboot and beat it!`);
        setScoreSubmissionState(false);
        closeScoreModal();
      } catch (error) {
        scoreModalStatus.textContent = error.message || 'Unable to save your score.';
        scoreModalSubmit.disabled = false;
      }
    });

    scoreModalName.addEventListener('keydown', (e) => {
      if (e.key === 'Enter') {
        e.preventDefault();
        scoreModalSubmit.click();
      }
    });

    const terrain = {
      step: 34,
      points: [],
      caves: [],
      precipices: [],
      lastX: 0,
      currentY: baseGroundY,
      slope: 0,
      nextPrecipiceAt: 420,
      nextCaveAt: 360
    };

    function rand(min, max) {
      return min + Math.random() * (max - min);
    }

    function clamp(value, min, max) {
      return Math.max(min, Math.min(max, value));
    }

    function isInPrecipice(worldX) {
      return terrain.precipices.some((drop) => worldX >= drop.start && worldX <= drop.end);
    }

    function getCaveAt(worldX) {
      return terrain.caves.find((cave) => worldX >= cave.start && worldX <= cave.end) || null;
    }

    function getCaveCeilingAt(worldX) {
      const cave = getCaveAt(worldX);
      if (!cave) return null;
      const wave = Math.sin((worldX * 0.04) + cave.phase) * cave.amplitude;
      return cave.baseCeiling + wave;
    }

    function getPrecipiceNear(worldX, padding = 0) {
      return terrain.precipices.find((drop) => worldX >= drop.start - padding && worldX <= drop.end + padding) || null;
    }

    function getRequiredGroundForJumpClearance(worldX) {
      const caveCeilingY = getCaveCeilingAt(worldX);
      if (caveCeilingY == null) return null;
      return caveCeilingY + courseSafety.minJumpClearance;
    }

    function enforceJumpClearanceOnSegment(previousPoint, nextPointX, nextPointY) {
      if (!previousPoint) return nextPointY;

      let adjustedNextY = nextPointY;
      const segmentWidth = nextPointX - previousPoint.x;
      if (segmentWidth <= 0) return adjustedNextY;

      function enforceAtSample(sampleX) {
        const requiredGroundY = getRequiredGroundForJumpClearance(sampleX);
        if (requiredGroundY == null) return;

        const t = (sampleX - previousPoint.x) / segmentWidth;
        if (t <= 0) return;

        const sampleGroundY = previousPoint.y + (adjustedNextY - previousPoint.y) * t;
        if (sampleGroundY >= requiredGroundY) return;

        const requiredNextY = previousPoint.y + ((requiredGroundY - previousPoint.y) / t);
        adjustedNextY = Math.max(adjustedNextY, requiredNextY);
      }

      for (let sampleX = previousPoint.x + courseSafety.clearanceSampleStep; sampleX < nextPointX; sampleX += courseSafety.clearanceSampleStep) {
        enforceAtSample(sampleX);
      }

      // Always validate the segment endpoint because sample stepping can skip nextPointX.
      enforceAtSample(nextPointX);

      return adjustedNextY;
    }

    function findTerrainSegmentIndex(worldX) {
      const points = terrain.points;
      if (points.length < 2) return 0;
      if (worldX <= points[0].x) return 0;

      let low = 0;
      let high = points.length - 2;
      while (low <= high) {
        const mid = Math.floor((low + high) * 0.5);
        const nextPointX = points[mid + 1].x;
        if (nextPointX < worldX) {
          low = mid + 1;
        } else {
          high = mid - 1;
        }
      }

      return clamp(low, 0, points.length - 2);
    }

    function getTerrainHeight(worldX) {
      if (isInPrecipice(worldX)) {
        return precipiceFloorY;
      }

      const points = terrain.points;
      const i = findTerrainSegmentIndex(worldX);
      const p1 = points[i];
      const p2 = points[Math.min(i + 1, points.length - 1)];
      if (!p1 || !p2) return baseGroundY;
      if (p1.x === p2.x) return p1.y;
      const t = (worldX - p1.x) / (p2.x - p1.x);
      return p1.y + (p2.y - p1.y) * t;
    }

    function applySpawnGap(gapPx, moveSpeed) {
      scheduledGapPx = gapPx;
      spawnTimer = (gapPx / moveSpeed) * (1000 / 60);
    }

    function ensureTerrainAhead(maxWorldX) {
      while (terrain.lastX < maxWorldX) {
        terrain.lastX += terrain.step;

        if (terrain.lastX > terrain.nextPrecipiceAt) {
          const precipiceStart = terrain.lastX + rand(40, 150);
          const precipiceWidth = rand(80, courseSafety.maxPrecipiceWidth);
          terrain.precipices.push({ start: precipiceStart, end: precipiceStart + precipiceWidth });
          terrain.nextPrecipiceAt = precipiceStart + rand(460, 780);
        }

        if (terrain.lastX > terrain.nextCaveAt) {
          const start = terrain.lastX + rand(60, 140);
          const length = rand(240, 430);
          const ceiling = rand(70, 140);
          terrain.caves.push({
            start,
            end: start + length,
            baseCeiling: ceiling,
            amplitude: rand(8, 18),
            phase: rand(0, Math.PI * 2)
          });
          terrain.nextCaveAt = start + rand(520, 880);
        }

        terrain.slope += rand(-0.36, 0.36);
        terrain.slope = clamp(terrain.slope, -1.8, 1.8);
        terrain.currentY += terrain.slope * terrain.step * 0.25;
        terrain.currentY += (baseGroundY - terrain.currentY) * 0.04;
        terrain.currentY = clamp(terrain.currentY, baseGroundY - 110, baseGroundY + 44);

        if (Math.random() < 0.09) {
          terrain.currentY += rand(-26, 22);
          terrain.currentY = clamp(terrain.currentY, baseGroundY - 110, baseGroundY + 44);
        }

        const previousPoint = terrain.points[terrain.points.length - 1];
        terrain.currentY = enforceJumpClearanceOnSegment(previousPoint, terrain.lastX, terrain.currentY);
        terrain.currentY = clamp(terrain.currentY, baseGroundY - 110, baseGroundY + 44);

        terrain.points.push({ x: terrain.lastX, y: terrain.currentY });
      }
    }

    function initTerrain() {
      terrain.points.length = 0;
      terrain.caves.length = 0;
      terrain.precipices.length = 0;
      terrain.lastX = 0;
      terrain.currentY = baseGroundY;
      terrain.slope = 0;
      terrain.nextPrecipiceAt = 420;
      terrain.nextCaveAt = 360;
      terrain.points.push({ x: 0, y: baseGroundY });
      ensureTerrainAhead(canvas.width * 2);
    }

    function createObstacle(action, worldX) {
      let groundY = getTerrainHeight(worldX);
      if (isInPrecipice(worldX)) {
        const precipice = terrain.precipices.find((seg) => worldX >= seg.start && worldX <= seg.end);
        worldX = (precipice ? precipice.end : worldX) + 50;
        groundY = getTerrainHeight(worldX);
      }

      if (action === 'stay') {
        return { worldX, y: groundY - 138, w: 72, h: 22, type: 'drone', action: 'stay' };
      }

      const typeRoll = Math.random();
      if (typeRoll < 0.34) {
        return { worldX, y: groundY - 20, w: 28, h: 20, type: 'bug', action: 'jump' };
      }
      if (typeRoll < 0.67) {
        return { worldX, y: groundY - 52, w: 36, h: 52, type: 'server', action: 'jump' };
      }
      return { worldX, y: groundY - 24, w: 62, h: 24, type: 'laser', action: 'jump' };
    }

    function pickRandomAction() {
      return Math.random() < 0.24 ? 'stay' : 'jump';
    }

    function getSpawnDelayMs(previousAction, nextAction) {
      const moveSpeed = baseSpeed * speedMult;
      const baselineFrames = Math.round(23 + Math.random() * 35);
      const randomGapPx = baselineFrames * moveSpeed;
      const minGapPx = getMinGapPx(previousAction, nextAction);
      const maxGapPx = minGapPx + moveSpeed * (16 + Math.random() * 18);
      const gapPx = Math.max(minGapPx, Math.min(randomGapPx, maxGapPx));
      return (gapPx / moveSpeed) * (1000 / 60);
    }

    function getMinGapPx(previousAction, nextAction) {
      const moveSpeed = baseSpeed * speedMult;
      const prevKey = previousAction || 'start';
      const requiredFrames = transitionFrameBudget[prevKey][nextAction];
      return requiredFrames * moveSpeed;
    }

    function canTransition(previousAction, nextAction, gapPx) {
      return gapPx >= getMinGapPx(previousAction, nextAction);
    }

    function hasNearbyObstacle(worldStart, worldEnd, ignoreObstacle = null) {
      return obstacles.some((placed) => {
        if (ignoreObstacle && placed === ignoreObstacle) return false;
        const placedStart = placed.worldX - courseSafety.obstacleSpacingBuffer;
        const placedEnd = placed.worldX + placed.w + courseSafety.obstacleSpacingBuffer;
        return worldStart < placedEnd && worldEnd > placedStart;
      });
    }

    function getPreviousObstacle(obstacleStart) {
      let previous = null;
      for (const candidate of obstacles) {
        const candidateEnd = candidate.worldX + candidate.w;
        if (candidateEnd <= obstacleStart && (!previous || candidateEnd > previous.worldX + previous.w)) {
          previous = candidate;
        }
      }
      return previous;
    }

    function hasCaveInSpan(worldStart, worldEnd) {
      for (let sampleX = worldStart; sampleX <= worldEnd; sampleX += courseSafety.clearanceSampleStep) {
        if (getCaveCeilingAt(sampleX) != null) {
          return true;
        }
      }
      return getCaveCeilingAt(worldEnd) != null;
    }

    function getRequiredObstacleGap(previousAction, nextAction, inCave) {
      const gapTable = inCave ? courseSafety.minObstacleGapPxInCave : courseSafety.minObstacleGapPx;
      const fromAction = previousAction || 'jump';
      return gapTable[fromAction][nextAction];
    }

    function isObstaclePlacementWinnable(obstacle, action) {
      const obstacleStart = obstacle.worldX;
      const obstacleEnd = obstacle.worldX + obstacle.w;
      const obstacleCenter = obstacleStart + obstacle.w * 0.5;
      const requiredLandingBuffer = action === 'stay' ? courseSafety.minLandingBufferForStay : courseSafety.minLandingBuffer;
      const requiredTakeoffBuffer = action === 'stay' ? courseSafety.minTakeoffBufferForStay : courseSafety.minTakeoffBuffer;

      if (action === 'jump') {
        // Jump prompts become unfair in tight caves: the player needs approach room and
        // vertical space before reaching the obstacle itself.
        const approachStart = obstacleStart - courseSafety.jumpObstacleCaveApproachBuffer;
        if (hasCaveInSpan(approachStart, obstacleEnd)) {
          return false;
        }

        // Prevent spawning jump prompts at the bottom of sharp downhill segments.
        const uphillSampleX = obstacleStart - player.w;
        const downhillAmount = getTerrainHeight(obstacleStart) - getTerrainHeight(uphillSampleX);
        if (downhillAmount > courseSafety.maxDownhillBeforeJumpObstacle) {
          return false;
        }
      } else if (action === 'stay') {
        // Duck prompts need enough stable ground afterward so the player can recover
        // and react to the next jump without running off a ledge.
        const postObstacleGround = getTerrainHeight(obstacleEnd);
        let lowestRunoutGround = postObstacleGround;
        const runoutEnd = obstacleEnd + courseSafety.stayObstacleRunoutDistance;
        for (let sampleX = obstacleEnd + courseSafety.clearanceSampleStep; sampleX <= runoutEnd; sampleX += courseSafety.clearanceSampleStep) {
          lowestRunoutGround = Math.max(lowestRunoutGround, getTerrainHeight(sampleX));
        }

        const downhillAfterStay = lowestRunoutGround - postObstacleGround;
        if (downhillAfterStay > courseSafety.maxDownhillAfterStayObstacle) {
          return false;
        }

        // Prevent drones from spawning immediately after a cliff/slope drop.
        // Scan the full takeoff-buffer approach zone and find the highest elevation
        // the player crossed. If the ground drops significantly into the drone
        // position, the player arrives with downhill momentum and little reaction
        // time. When a cave ceiling is also present the player cannot jump to
        // escape, making the hit unavoidable.
        const droneApproachStart = obstacleStart - requiredTakeoffBuffer;
        let peakApproachY = getTerrainHeight(droneApproachStart);
        for (let sampleX = droneApproachStart + courseSafety.clearanceSampleStep; sampleX < obstacleStart; sampleX += courseSafety.clearanceSampleStep) {
          peakApproachY = Math.min(peakApproachY, getTerrainHeight(sampleX));
        }
        const approachDrop = getTerrainHeight(obstacleStart) - peakApproachY;
        const approachHasCave = hasCaveInSpan(droneApproachStart, obstacleEnd);
        const maxApproachDrop = approachHasCave
          ? courseSafety.maxDownhillBeforeDroneInCave
          : courseSafety.maxDownhillBeforeDrone;
        if (approachDrop > maxApproachDrop) {
          return false;
        }
      }

      if (hasNearbyObstacle(obstacleStart, obstacleEnd, obstacle)) {
        return false;
      }

      const previousObstacle = getPreviousObstacle(obstacleStart);
      if (previousObstacle) {
        const prevEnd = previousObstacle.worldX + previousObstacle.w;
        const transitionStart = prevEnd;
        const transitionEnd = obstacleStart + obstacle.w * 0.2;
        const inCaveTransition = hasCaveInSpan(transitionStart, transitionEnd);
        const requiredGap = getRequiredObstacleGap(previousObstacle.action, action, inCaveTransition);
        if (obstacleStart - prevEnd < requiredGap) {
          return false;
        }
      }

      if (getPrecipiceNear(obstacleStart, courseSafety.precipiceAvoidanceBuffer) || getPrecipiceNear(obstacleEnd, courseSafety.precipiceAvoidanceBuffer)) {
        return false;
      }

      const adjacentPrecipice = terrain.precipices.find((drop) => (
        obstacleStart >= drop.end && obstacleStart - drop.end < requiredLandingBuffer
      ) || (
        obstacleEnd <= drop.start && drop.start - obstacleEnd < requiredTakeoffBuffer
      ));
      if (adjacentPrecipice) {
        return false;
      }

      // Sample player.w before and after the obstacle footprint so that low
      // ceilings in the approach/landing zone are caught, not just directly
      // above the obstacle itself.
      const ceilingSampleStart = obstacleStart - player.w;
      const ceilingSampleEnd   = obstacleEnd   + player.w;
      for (let sampleX = ceilingSampleStart; sampleX <= ceilingSampleEnd; sampleX += courseSafety.clearanceSampleStep) {
        const groundY = getTerrainHeight(sampleX);
        const caveCeilingY = getCaveCeilingAt(sampleX);

        if (caveCeilingY != null) {
          const headroom = groundY - caveCeilingY;
          if (headroom < courseSafety.minCaveHeadroomForAnyObstacle) {
            return false;
          }
          if (action === 'jump' && headroom < courseSafety.minCaveHeadroomForJumpObstacle) {
            return false;
          }
          // Ground objects sit on the terrain surface, so the player must also
          // clear the obstacle's own height. Ensure at least 2√ó the player's
          // height remains between the obstacle top and the cave ceiling.
          if (action === 'jump' && headroom - obstacle.h < player.h * 2.0) {
            return false;
          }
        }

        if (hasNearbyObstacle(sampleX - 8, sampleX + 8, obstacle) && caveCeilingY != null) {
          const localHeadroom = groundY - caveCeilingY;
          if (localHeadroom < courseSafety.minCaveHeadroom + 10) {
            return false;
          }
        }
      }

      const centerGroundY = getTerrainHeight(obstacleCenter);
      const centerCaveCeilingY = getCaveCeilingAt(obstacleCenter);
      if (centerCaveCeilingY != null) {
        const centerHeadroom = centerGroundY - centerCaveCeilingY;
        if (centerHeadroom < courseSafety.minCaveHeadroom) {
          return false;
        }
        // Same 2√ó player-height clearance above the obstacle top at the centre.
        if (action === 'jump' && centerHeadroom - obstacle.h < player.h * 2.0) {
          return false;
        }
      }

      return true;
    }

    function scheduleNextObstacle() {
      const moveSpeed = baseSpeed * speedMult;
      const spawnEdgeX = worldOffset + canvas.width + 20;
      const preferredAction = queuedSpawnAction;
      const transitionGapPx = lastSpawnAction ? scheduledGapPx : Number.POSITIVE_INFINITY;

      for (let attempt = 0; attempt < 24; attempt++) {
        const nextAction = attempt === 0 && preferredAction ? preferredAction : pickRandomAction();
        if (!canTransition(lastSpawnAction, nextAction, transitionGapPx)) {
          continue;
        }

        const obstacle = createObstacle(nextAction, spawnEdgeX);
        if (!isObstaclePlacementWinnable(obstacle, nextAction)) {
          continue;
        }

        const spawnShiftPx = Math.max(0, obstacle.worldX - spawnEdgeX);
        obstacles.push(obstacle);
        lastSpawnAction = nextAction;
        queuedSpawnAction = null;

        for (let previewAttempt = 0; previewAttempt < 24; previewAttempt++) {
          const previewAction = pickRandomAction();
          const previewGapPx = getSpawnDelayMs(nextAction, previewAction) * moveSpeed * (60 / 1000);
          if (!canTransition(nextAction, previewAction, previewGapPx)) {
            continue;
          }

          applySpawnGap(previewGapPx + spawnShiftPx, moveSpeed);
          queuedSpawnAction = previewAction;
          return;
        }

        const fallbackGapPx = getSpawnDelayMs(nextAction, 'jump') * moveSpeed * (60 / 1000);
        applySpawnGap(fallbackGapPx + spawnShiftPx, moveSpeed);
        queuedSpawnAction = 'jump';
        return;
      }

      const fallbackAction = preferredAction || 'jump';
      const fallbackObstacle = createObstacle(fallbackAction, spawnEdgeX);
      if (isObstaclePlacementWinnable(fallbackObstacle, fallbackAction)) {
        const fallbackShiftPx = Math.max(0, fallbackObstacle.worldX - spawnEdgeX);
        obstacles.push(fallbackObstacle);
        lastSpawnAction = fallbackAction;
        const fallbackNextAction = 'jump';
        applySpawnGap(getSpawnDelayMs(fallbackAction, fallbackNextAction) * moveSpeed * (60 / 1000) + fallbackShiftPx, moveSpeed);
        queuedSpawnAction = fallbackNextAction;
        return;
      }
      const fallbackNextAction = 'jump';
      applySpawnGap(getSpawnDelayMs(fallbackAction, fallbackNextAction) * moveSpeed * (60 / 1000), moveSpeed);
      queuedSpawnAction = fallbackNextAction;
    }

    function drawSkyline() {
      sceneryOffset += (baseSpeed * speedMult) * 0.3;

      for (let i = 0; i < 6; i++) {
        const width = 130;
        const x = (i * 170) - (sceneryOffset % 170);
        const h = 110 + (i % 3) * 30;
        ctx.fillStyle = 'rgba(141,89,255,0.22)';
        ctx.fillRect(x, baseGroundY - h, width, h);

        ctx.fillStyle = 'rgba(46,248,255,0.6)';
        for (let wy = baseGroundY - h + 12; wy < baseGroundY - 10; wy += 20) {
          for (let wx = x + 12; wx < x + width - 10; wx += 22) {
            ctx.fillRect(wx, wy, 8, 9);
          }
        }
      }

      ctx.fillStyle = 'rgba(255,255,255,0.7)';
      for (let i = 0; i < 45; i++) {
        const starX = (i * 41 + 17) % canvas.width;
        const starY = (i * 29 + 23) % (baseGroundY - 130);
        ctx.fillRect((starX + sceneryOffset * 0.12) % canvas.width, starY, 2, 2);
      }
    }

    function drawGround() {
      groundOffset += baseSpeed * speedMult;
      const renderWorldOffset = Math.floor(worldOffset);
      const startWorld = renderWorldOffset - terrain.step;
      const endWorld = renderWorldOffset + canvas.width + terrain.step * 2;
      const groundSampleStep = 6;
      ensureTerrainAhead(endWorld + 300);

      ctx.fillStyle = '#16233f';
      ctx.beginPath();
      ctx.moveTo(0, canvas.height);
      for (let sx = -terrain.step; sx <= canvas.width + terrain.step; sx += groundSampleStep) {
        const worldX = renderWorldOffset + sx;
        const gy = Math.round(getTerrainHeight(worldX));
        ctx.lineTo(sx, gy);
      }
      ctx.lineTo(canvas.width, canvas.height);
      ctx.closePath();
      ctx.fill();

      for (let x = -(groundOffset % 42); x < canvas.width; x += 42) {
        const gy = getTerrainHeight(worldOffset + x + 8);
        if (gy >= canvas.height - 4) continue;
        ctx.fillStyle = 'rgba(46,248,255,0.7)';
        ctx.fillRect(x, gy + 20, 24, 4);
      }

      ctx.fillStyle = '#16233f';
      terrain.caves.forEach((cave) => {
        if (cave.end < worldOffset - 40 || cave.start > worldOffset + canvas.width + 40) return;
        const startX = cave.start - renderWorldOffset;
        const endX = cave.end - renderWorldOffset;
        ctx.beginPath();
        ctx.moveTo(startX, 0);
        ctx.lineTo(startX, cave.baseCeiling);
        for (let worldX = cave.start; worldX <= cave.end; worldX += 16) {
          const sx = worldX - renderWorldOffset;
          const wave = Math.sin((worldX * 0.04) + cave.phase) * cave.amplitude;
          ctx.lineTo(sx, cave.baseCeiling + wave);
        }
        const endWave = Math.sin((cave.end * 0.04) + cave.phase) * cave.amplitude;
        ctx.lineTo(endX, cave.baseCeiling + endWave);
        ctx.lineTo(endX, 0);
        ctx.closePath();
        ctx.fill();
      });

    }

    function drawPlayer() {
      const g = ctx.createLinearGradient(player.x, player.y, player.x + player.w, player.y + player.h);
      g.addColorStop(0, '#2ef8ff');
      g.addColorStop(1, '#8e5cff');
      ctx.fillStyle = g;
      roundRect(ctx, player.x, player.y, player.w, player.h, 10);
      ctx.fill();

      ctx.fillStyle = '#e9f6ff';
      ctx.font = 'bold 15px monospace';
      ctx.fillText('</>', player.x + 7, player.y + 34);
    }

    function drawObstacle(ob) {
      if (ob.type === 'bug') {
        ctx.font = '28px serif';
        ctx.fillText('üêû', ob.x, ob.y + ob.h);
      } else if (ob.type === 'server') {
        ctx.fillStyle = '#ff5a7c';
        roundRect(ctx, ob.x, ob.y, ob.w, ob.h, 7);
        ctx.fill();
        ctx.fillStyle = '#12020a';
        ctx.fillRect(ob.x + 8, ob.y + 12, ob.w - 16, 6);
        ctx.fillRect(ob.x + 8, ob.y + 26, ob.w - 16, 6);
      } else if (ob.type === 'drone') {
        ctx.fillStyle = 'rgba(255, 202, 95, 0.9)';
        roundRect(ctx, ob.x, ob.y, ob.w, ob.h, 8);
        ctx.fill();
        ctx.fillStyle = '#3e2b09';
        ctx.fillRect(ob.x + 10, ob.y + 8, ob.w - 20, 6);
        ctx.fillStyle = '#ffd95c';
        ctx.fillRect(ob.x + 30, ob.y + ob.h, 12, 12);
      } else {
        const lg = ctx.createLinearGradient(ob.x, ob.y, ob.x, ob.y + ob.h);
        lg.addColorStop(0, 'rgba(255,83,112,0.95)');
        lg.addColorStop(1, 'rgba(255,83,112,0.25)');
        ctx.fillStyle = lg;
        ctx.fillRect(ob.x, ob.y, ob.w, ob.h);
      }
    }

    function roundRect(ctx, x, y, w, h, r) {
      ctx.beginPath();
      ctx.moveTo(x + r, y);
      ctx.arcTo(x + w, y, x + w, y + h, r);
      ctx.arcTo(x + w, y + h, x, y + h, r);
      ctx.arcTo(x, y + h, x, y, r);
      ctx.arcTo(x, y, x + w, y, r);
      ctx.closePath();
    }

    function resetGame() {
      closeScoreModal();
      gameOverOverlay.classList.remove('active');
      gameStarted = true;
      score = 0;
      speedMult = 1;
      baseSpeed = 4.2;
      gameOver = false;
      spawnTimer = 0;
      scheduledGapPx = 0;
      obstacles.length = 0;
      lastSpawnAction = null;
      queuedSpawnAction = null;
      worldOffset = 0;
      latestRunScore = 0;
      setScoreSubmissionState(false);
      setLeaderboardStatus('Finish a run, then save your score to the global board.');
      fetchLeaderboard();
      initTerrain();
      const spawnGround = getTerrainHeight(player.x + player.w * 0.5) || baseGroundY;
      player.y = spawnGround - player.h;
      player.vy = 0;
      player.onGround = true;
      player.jumpsLeft = 2;
      updateHud();
      requestAnimationFrame(loop);
    }

    function updateHud() {
      scoreEl.textContent = Math.floor(score);
      speedEl.textContent = speedMult.toFixed(1);
      bestEl.textContent = Math.floor(best);
    }

    let lastSpawnAction = null;
    let queuedSpawnAction = null;

    function update() {
      if (gameOver) return;

      score += 0.2 * speedMult;
      speedMult = Math.min(6, 1 + score / 340);

      const moveSpeed = baseSpeed * speedMult;
      worldOffset += moveSpeed;
      ensureTerrainAhead(worldOffset + canvas.width + 460);

      // Prune terrain data that is far behind the camera to prevent unbounded memory growth.
      const pruneX = worldOffset - canvas.width * 3;
      let pruneTo = 0;
      while (pruneTo + 1 < terrain.points.length && terrain.points[pruneTo + 1].x < pruneX) {
        pruneTo++;
      }
      if (pruneTo > 0) terrain.points.splice(0, pruneTo);
      terrain.caves = terrain.caves.filter(c => c.end >= pruneX);
      terrain.precipices = terrain.precipices.filter(p => p.end >= pruneX);

      player.vy += gravity;
      player.y += player.vy;

      const playerWorldCenter = worldOffset + player.x + player.w * 0.5;
      const currentGround = getTerrainHeight(playerWorldCenter);
      if (isInPrecipice(playerWorldCenter)) {
        player.onGround = false;
        if (player.y + player.h >= currentGround) {
          gameOver = true;
        }
      } else if (player.y >= currentGround - player.h) {
        player.y = currentGround - player.h;
        player.vy = 0;
        player.onGround = true;
        player.jumpsLeft = 2;
      } else {
        player.onGround = false;
      }

      const activeCave = getCaveAt(playerWorldCenter);
      if (activeCave) {
        const ceilingWave = Math.sin((playerWorldCenter * 0.04) + activeCave.phase) * activeCave.amplitude;
        const ceilingY = activeCave.baseCeiling + ceilingWave;
        if (player.y <= ceilingY) {
          gameOver = true;
        }
      }

      if (player.y > canvas.height + 80) {
        gameOver = true;
      }

      spawnTimer -= 16.7;
      if (spawnTimer <= 0) {
        scheduleNextObstacle();
      }

      for (let i = obstacles.length - 1; i >= 0; i--) {
        const ob = obstacles[i];
        const obScreenX = ob.worldX - worldOffset;

        const hit = player.x < obScreenX + ob.w &&
                    player.x + player.w > obScreenX &&
                    player.y < ob.y + ob.h &&
                    player.y + player.h > ob.y;

        if (hit) {
          gameOver = true;
          best = Math.max(best, score);
          localStorage.setItem('techFlowRunnerBest', String(Math.floor(best)));
          latestRunScore = Math.floor(score);
          setScoreSubmissionState(latestRunScore > 0);
          setLeaderboardStatus(`Run ended at ${latestRunScore}m. Submit your score or press R to restart.`);
          updateHud();
          return;
        }

        if (obScreenX + ob.w < -20) {
          obstacles.splice(i, 1);
        }
      }

      if (gameOver) {
        best = Math.max(best, score);
        localStorage.setItem('techFlowRunnerBest', String(Math.floor(best)));
      }

      if (gameOver) {
        latestRunScore = Math.floor(score);
        setScoreSubmissionState(latestRunScore > 0);
        setLeaderboardStatus(`Run ended at ${latestRunScore}m. Submit your score or press R to restart.`);
      }

      updateHud();
    }

    function drawGameOver() {
      ctx.fillStyle = 'rgba(3, 7, 18, 0.74)';
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      ctx.fillStyle = '#fff';
      ctx.textAlign = 'center';
      ctx.font = '700 44px Segoe UI';
      ctx.fillText('Signal Lost', canvas.width / 2, canvas.height / 2 - 28);
      ctx.font = '600 24px Segoe UI';
      ctx.fillText(`Distance: ${Math.floor(score)}m`, canvas.width / 2, canvas.height / 2 + 12);
      ctx.font = '500 18px Segoe UI';
      ctx.fillText('Press R to restart  ¬∑  Use Submit Score to save', canvas.width / 2, canvas.height / 2 + 48);
      ctx.textAlign = 'left';
    }

    function render() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      drawSkyline();
      drawGround();
      drawPlayer();
      obstacles.forEach((ob) => {
        const screenObstacle = { ...ob, x: ob.worldX - worldOffset };
        drawObstacle(screenObstacle);
      });
      if (gameOver) {
        drawGameOver();
        gameOverOverlay.classList.add('active');
      }
    }

    function loop() {
      update();
      render();
      if (!gameOver) requestAnimationFrame(loop);
    }

    function jump() {
      if (!gameStarted || gameOver || player.jumpsLeft <= 0) return;
      player.vy = player.jumpPower;
      player.onGround = false;
      player.jumpsLeft -= 1;
    }

    window.addEventListener('keydown', (e) => {
      if (!scoreModal.hidden) return;
      const key = e.key.toLowerCase();
      if (key === ' ' || key === 'arrowup' || key === 'w') {
        e.preventDefault();
        jump();
      }
      if (gameOver && key === 'r') {
        resetGame();
      }
    });

    canvas.addEventListener('pointerdown', jump);

    initTerrain();
    const initialGround = getTerrainHeight(player.x + player.w * 0.5) || baseGroundY;
    player.y = initialGround - player.h;

    updateHud();
    setScoreSubmissionState(false);
    fetchLeaderboard();
    setInterval(fetchLeaderboard, 60000);

    // Draw initial static frame so the canvas isn't blank behind the start overlay
    render();

    function startGame() {
      startOverlay.classList.add('hidden');
      gameStarted = true;
      requestAnimationFrame(loop);
    }

    startBtn.addEventListener('click', startGame);

    // Also allow Space/W/‚Üë to dismiss the start overlay
    window.addEventListener('keydown', (e) => {
      if (!gameStarted) {
        const k = e.key.toLowerCase();
        if (k === ' ' || k === 'arrowup' || k === 'w') {
          e.preventDefault();
          startGame();
        }
      }
    }, { capture: true });

    // Fullscreen / Scroll-lock button
    const fullscreenBtn = document.getElementById('fullscreenBtn');

    function isFullscreenSupported() {
      const el = document.documentElement;
      return !!(el.requestFullscreen || el.webkitRequestFullscreen);
    }

    function isFullscreen() {
      return !!(document.fullscreenElement || document.webkitFullscreenElement);
    }

    const FS_ENTER_SVG     = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" width="20" height="20"><path d="M7 14H5v5h5v-2H7v-3zm-2-4h2V7h3V5H5v5zm12 7h-3v2h5v-5h-2v3zM14 5v2h3v3h2V5h-5z"/></svg>';
    const FS_EXIT_SVG      = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" width="20" height="20"><path d="M5 16h3v3h2v-5H5v2zm3-8H5v2h5V5H8v3zm6 11h2v-3h3v-2h-5v5zm2-11V5h-2v5h5V8h-3z"/></svg>';
    const SCROLL_LOCK_SVG   = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" width="20" height="20"><path d="M18 8h-1V6c0-2.76-2.24-5-5-5S7 3.24 7 6v2H6c-1.1 0-2 .9-2 2v10c0 1.1.9 2 2 2h12c1.1 0 2-.9 2-2V10c0-1.1-.9-2-2-2zm-6 9c-1.1 0-2-.9-2-2s.9-2 2-2 2 .9 2 2-.9 2-2 2zm3.1-9H8.9V6c0-1.71 1.39-3.1 3.1-3.1 1.71 0 3.1 1.39 3.1 3.1v2z"/></svg>';
    const SCROLL_UNLOCK_SVG = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" width="20" height="20"><path d="M12 1C9.24 1 7 3.24 7 6v2H6c-1.1 0-2 .9-2 2v10c0 1.1.9 2 2 2h12c1.1 0 2-.9 2-2V10c0-1.1-.9-2-2-2H9V6c0-1.66 1.34-3 3-3 1.66 0 3 1.34 3 3h2c0-2.76-2.24-5-5-5zm0 15c-1.1 0-2-.9-2-2s.9-2 2-2 2 .9 2 2-.9 2-2 2z"/></svg>';

    if (isFullscreenSupported()) {
      // --- Fullscreen mode (Android, desktop) ---
      function updateFullscreenBtn() {
        fullscreenBtn.innerHTML = isFullscreen() ? FS_EXIT_SVG : FS_ENTER_SVG;
        fullscreenBtn.setAttribute('aria-label', isFullscreen() ? 'Exit full screen' : 'Enter full screen');
        document.body.classList.toggle('game-fullscreen', isFullscreen());
      }

      fullscreenBtn.style.display = 'inline-block';
      updateFullscreenBtn();

      fullscreenBtn.addEventListener('click', () => {
        if (!isFullscreen()) {
          const el = document.documentElement;
          if (el.requestFullscreen) el.requestFullscreen();
          else if (el.webkitRequestFullscreen) el.webkitRequestFullscreen();
        } else {
          if (document.exitFullscreen) document.exitFullscreen();
          else if (document.webkitExitFullscreen) document.webkitExitFullscreen();
        }
      });

      document.addEventListener('fullscreenchange', updateFullscreenBtn);
      document.addEventListener('webkitfullscreenchange', updateFullscreenBtn);

    } else if (navigator.maxTouchPoints > 0) {
      // --- Scroll-lock mode (iOS PWA and other touch devices without fullscreen API) ---
      let scrollLocked = false;
      let savedScrollY = 0;
      const viewportMeta = document.querySelector('meta[name="viewport"]');

      function preventScroll(e) { e.preventDefault(); }
      // Block pinch-to-zoom while scroll-locked
      function preventZoom(e) { if (e.touches.length > 1) e.preventDefault(); }

      function lockBodyScroll() {
        savedScrollY = window.scrollY;
        // position:fixed freezes the page in place, preventing iOS edge bounce
        document.body.style.position = 'fixed';
        document.body.style.top = `-${savedScrollY}px`;
        document.body.style.left = '0';
        document.body.style.right = '0';
        document.body.style.width = '100%';
        document.body.style.overscrollBehavior = 'none';
        document.documentElement.style.overscrollBehavior = 'none';
        document.addEventListener('touchmove', preventScroll, { passive: false });
        document.addEventListener('touchstart', preventZoom, { passive: false });
        // Disable pinch-zoom and double-tap zoom via viewport
        if (viewportMeta) {
          viewportMeta.content = 'width=device-width, initial-scale=1.0, viewport-fit=cover, user-scalable=no, maximum-scale=1.0';
        }
      }

      function unlockBodyScroll() {
        document.body.style.position = '';
        document.body.style.top = '';
        document.body.style.left = '';
        document.body.style.right = '';
        document.body.style.width = '';
        document.body.style.overscrollBehavior = '';
        document.documentElement.style.overscrollBehavior = '';
        document.removeEventListener('touchmove', preventScroll);
        document.removeEventListener('touchstart', preventZoom);
        if (viewportMeta) {
          viewportMeta.content = 'width=device-width, initial-scale=1.0, viewport-fit=cover';
        }
        window.scrollTo(0, savedScrollY);
      }

      function updateScrollLockBtn() {
        fullscreenBtn.innerHTML = scrollLocked ? SCROLL_LOCK_SVG : SCROLL_UNLOCK_SVG;
        fullscreenBtn.setAttribute('aria-label', scrollLocked ? 'Unlock scroll' : 'Lock scroll');
        fullscreenBtn.dataset.locked = scrollLocked;
      }

      fullscreenBtn.style.display = 'inline-block';
      updateScrollLockBtn();

      fullscreenBtn.addEventListener('click', () => {
        scrollLocked = !scrollLocked;
        if (scrollLocked) {
          lockBodyScroll();
        } else {
          unlockBodyScroll();
        }
        updateScrollLockBtn();
      });

      window.addEventListener('orientationchange', () => {
        if (scrollLocked) {
          scrollLocked = false;
          unlockBodyScroll();
          updateScrollLockBtn();
        }
      });
    }

    // PWA install prompt
    let deferredInstallPrompt = null;
    const installBtn = document.getElementById('installBtn');

    window.addEventListener('beforeinstallprompt', (e) => {
      e.preventDefault();
      deferredInstallPrompt = e;
      installBtn.style.display = 'inline-block';
    });

    installBtn.addEventListener('click', () => {
      if (!deferredInstallPrompt) return;
      deferredInstallPrompt.prompt();
      deferredInstallPrompt.userChoice.then(() => {
        deferredInstallPrompt = null;
        installBtn.style.display = 'none';
      });
    });

    window.addEventListener('appinstalled', () => {
      deferredInstallPrompt = null;
      installBtn.style.display = 'none';
    });

    if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
        navigator.serviceWorker.register('/sw.js')
          .then((reg) => {
            // Proactively check for a new SW version on every load.
            reg.update();
            reg.onupdatefound = () => {
              const newWorker = reg.installing;
              newWorker.onstatechange = () => {
                // A new SW has installed and the old one was controlling the page ‚Äî
                // reload silently so users always get the latest cached assets.
                if (newWorker.state === 'installed' && navigator.serviceWorker.controller) {
                  window.location.reload();
                }
              };
            };
          })
          .catch((error) => {
            console.warn('Service worker registration failed:', error);
          });
      });
    }
  </script>
</body>
</html>
