<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Tech Flow Runner</title>
  <style>
    :root {
      --bg-top: #0a1330;
      --bg-bottom: #050910;
      --neon: #2ef8ff;
      --accent: #8e5cff;
      --ground: #16233f;
      --text: #e9f6ff;
    }
    * { box-sizing: border-box; }
    body {
      margin: 0;
      min-height: 100vh;
      font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
      color: var(--text);
      background: radial-gradient(circle at 15% 10%, #1b2e5f, var(--bg-top) 45%, var(--bg-bottom));
      display: grid;
      place-items: center;
      overflow: hidden;
    }
    .wrap {
      width: min(96vw, 900px);
      text-align: center;
    }
    h1 {
      margin: 0 0 10px;
      color: var(--neon);
      text-shadow: 0 0 12px rgba(46, 248, 255, 0.6);
      letter-spacing: 0.8px;
    }
    .hud {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 10px;
      margin-bottom: 10px;
      font-weight: 700;
    }
    .chip {
      padding: 10px;
      border-radius: 12px;
      border: 1px solid rgba(255,255,255,0.2);
      background: rgba(255,255,255,0.08);
      backdrop-filter: blur(4px);
    }
    canvas {
      width: 100%;
      height: auto;
      border-radius: 14px;
      border: 2px solid rgba(46, 248, 255, 0.35);
      box-shadow: 0 0 26px rgba(46, 248, 255, 0.25);
      background: linear-gradient(180deg, #111f45 0%, #0a1020 70%);
    }
    .controls {
      margin-top: 10px;
      opacity: 0.9;
    }
    .button-row {
      display: inline-flex;
      gap: 10px;
      flex-wrap: wrap;
      justify-content: center;
    }
    button {
      margin-top: 12px;
      border: 0;
      border-radius: 999px;
      padding: 10px 18px;
      font-weight: 700;
      color: #071425;
      background: linear-gradient(115deg, var(--neon), #75ffd4);
      cursor: pointer;
    }
  </style>
</head>
<body>
  <main class="wrap">
    <h1>üèÉ Tech Flow Runner</h1>
    <section class="hud">
      <div class="chip">Distance: <span id="score">0</span>m</div>
      <div class="chip">Speed: <span id="speed">1.0</span>x</div>
      <div class="chip">Best: <span id="best">0</span>m</div>
    </section>
    <canvas id="game" width="900" height="420" aria-label="Tech Flow jump runner"></canvas>
    <div class="controls">Double jump with <strong>Space</strong>, <strong>W</strong>, or <strong>‚Üë</strong>. Press <strong>R</strong> to restart.</div>
    <div class="button-row">
      <button id="musicBtn" type="button">Play Music</button>
      <button id="resetBestBtn" type="button">Reset Best</button>
    </div>
  </main>

  <audio id="bgm" src="Tech Flow.mp3" loop preload="auto"></audio>

  <script>
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const scoreEl = document.getElementById('score');
    const speedEl = document.getElementById('speed');
    const bestEl = document.getElementById('best');
    const music = document.getElementById('bgm');
    const musicBtn = document.getElementById('musicBtn');
    const resetBestBtn = document.getElementById('resetBestBtn');

    let score = 0;
    let best = Number(localStorage.getItem('techFlowRunnerBest') || 0);
    let speedMult = 1;
    let baseSpeed = 4.2;
    let gameOver = false;
    let groundOffset = 0;
    let sceneryOffset = 0;
    let spawnTimer = 0;
    let worldOffset = 0;

    const gravity = 0.75;
    const player = {
      x: 120,
      y: 0,
      w: 48,
      h: 58,
      vy: 0,
      jumpPower: -14,
      onGround: true,
      jumpsLeft: 2
    };
    const baseGroundY = canvas.height - 72;
    const precipiceFloorY = canvas.height - 1;
    player.y = baseGroundY - player.h;

    const obstacles = [];
    const spawnActions = ['jump', 'stay'];
    const transitionFrameBudget = {
      start: { jump: 24, stay: 20 },
      jump: { jump: 22, stay: 44 },
      stay: { jump: 26, stay: 18 }
    };
    const courseSafety = {
      minTakeoffBuffer: 96,
      minLandingBuffer: 162,
      minCaveHeadroom: player.h + 14,
      minCaveHeadroomForJumpObstacle: 124,
      minCaveHeadroomForAnyObstacle: 112,
      minJumpClearance: player.h + 138,
      clearanceSampleStep: 8,
      maxPrecipiceWidth: 136,
      precipiceAvoidanceBuffer: 80,
      obstacleSpacingBuffer: 28
    };

    function tryPlayMusic() {
      music.volume = 0.55;
      music.play().then(() => {
        musicBtn.textContent = 'Music Playing üéµ';
      }).catch(() => {
        musicBtn.textContent = 'Tap to Enable Music';
      });
    }

    musicBtn.addEventListener('click', tryPlayMusic);

    resetBestBtn.addEventListener('click', () => {
      best = 0;
      localStorage.setItem('techFlowRunnerBest', '0');
      updateHud();
    });

    const terrain = {
      step: 34,
      points: [],
      caves: [],
      precipices: [],
      lastX: 0,
      currentY: baseGroundY,
      slope: 0,
      nextPrecipiceAt: 420,
      nextCaveAt: 360
    };

    function rand(min, max) {
      return min + Math.random() * (max - min);
    }

    function clamp(value, min, max) {
      return Math.max(min, Math.min(max, value));
    }

    function isInPrecipice(worldX) {
      return terrain.precipices.some((drop) => worldX >= drop.start && worldX <= drop.end);
    }

    function getCaveAt(worldX) {
      return terrain.caves.find((cave) => worldX >= cave.start && worldX <= cave.end) || null;
    }

    function getCaveCeilingAt(worldX) {
      const cave = getCaveAt(worldX);
      if (!cave) return null;
      const wave = Math.sin((worldX * 0.04) + cave.phase) * cave.amplitude;
      return cave.baseCeiling + wave;
    }

    function getPrecipiceNear(worldX, padding = 0) {
      return terrain.precipices.find((drop) => worldX >= drop.start - padding && worldX <= drop.end + padding) || null;
    }

    function getRequiredGroundForJumpClearance(worldX) {
      const caveCeilingY = getCaveCeilingAt(worldX);
      if (caveCeilingY == null) return null;
      return caveCeilingY + courseSafety.minJumpClearance;
    }

    function enforceJumpClearanceOnSegment(previousPoint, nextPointX, nextPointY) {
      if (!previousPoint) return nextPointY;

      let adjustedNextY = nextPointY;
      const segmentWidth = nextPointX - previousPoint.x;
      if (segmentWidth <= 0) return adjustedNextY;

      function enforceAtSample(sampleX) {
        const requiredGroundY = getRequiredGroundForJumpClearance(sampleX);
        if (requiredGroundY == null) return;

        const t = (sampleX - previousPoint.x) / segmentWidth;
        if (t <= 0) return;

        const sampleGroundY = previousPoint.y + (adjustedNextY - previousPoint.y) * t;
        if (sampleGroundY >= requiredGroundY) return;

        const requiredNextY = previousPoint.y + ((requiredGroundY - previousPoint.y) / t);
        adjustedNextY = Math.max(adjustedNextY, requiredNextY);
      }

      for (let sampleX = previousPoint.x + courseSafety.clearanceSampleStep; sampleX < nextPointX; sampleX += courseSafety.clearanceSampleStep) {
        enforceAtSample(sampleX);
      }

      // Always validate the segment endpoint because sample stepping can skip nextPointX.
      enforceAtSample(nextPointX);

      return adjustedNextY;
    }

    function getTerrainHeight(worldX) {
      if (isInPrecipice(worldX)) {
        return precipiceFloorY;
      }

      const points = terrain.points;
      let i = 0;
      while (i < points.length - 1 && points[i + 1].x < worldX) {
        i += 1;
      }
      const p1 = points[i];
      const p2 = points[Math.min(i + 1, points.length - 1)];
      if (!p1 || !p2) return baseGroundY;
      if (p1.x === p2.x) return p1.y;
      const t = (worldX - p1.x) / (p2.x - p1.x);
      return p1.y + (p2.y - p1.y) * t;
    }

    function ensureTerrainAhead(maxWorldX) {
      while (terrain.lastX < maxWorldX) {
        terrain.lastX += terrain.step;

        if (terrain.lastX > terrain.nextPrecipiceAt) {
          const precipiceStart = terrain.lastX + rand(40, 150);
          const precipiceWidth = rand(80, courseSafety.maxPrecipiceWidth);
          terrain.precipices.push({ start: precipiceStart, end: precipiceStart + precipiceWidth });
          terrain.nextPrecipiceAt = precipiceStart + rand(460, 780);
        }

        if (terrain.lastX > terrain.nextCaveAt) {
          const start = terrain.lastX + rand(60, 140);
          const length = rand(240, 430);
          const ceiling = rand(70, 140);
          terrain.caves.push({
            start,
            end: start + length,
            baseCeiling: ceiling,
            amplitude: rand(8, 18),
            phase: rand(0, Math.PI * 2)
          });
          terrain.nextCaveAt = start + rand(520, 880);
        }

        terrain.slope += rand(-0.36, 0.36);
        terrain.slope = clamp(terrain.slope, -1.8, 1.8);
        terrain.currentY += terrain.slope * terrain.step * 0.25;
        terrain.currentY += (baseGroundY - terrain.currentY) * 0.04;
        terrain.currentY = clamp(terrain.currentY, baseGroundY - 110, baseGroundY + 44);

        if (Math.random() < 0.09) {
          terrain.currentY += rand(-26, 22);
          terrain.currentY = clamp(terrain.currentY, baseGroundY - 110, baseGroundY + 44);
        }

        const previousPoint = terrain.points[terrain.points.length - 1];
        terrain.currentY = enforceJumpClearanceOnSegment(previousPoint, terrain.lastX, terrain.currentY);

        terrain.points.push({ x: terrain.lastX, y: terrain.currentY });
      }
    }

    function initTerrain() {
      terrain.points.length = 0;
      terrain.caves.length = 0;
      terrain.precipices.length = 0;
      terrain.lastX = 0;
      terrain.currentY = baseGroundY;
      terrain.slope = 0;
      terrain.nextPrecipiceAt = 420;
      terrain.nextCaveAt = 360;
      terrain.points.push({ x: 0, y: baseGroundY });
      ensureTerrainAhead(canvas.width * 2);
    }

    function createObstacle(action, worldX) {
      let groundY = getTerrainHeight(worldX);
      if (isInPrecipice(worldX)) {
        const precipice = terrain.precipices.find((seg) => worldX >= seg.start && worldX <= seg.end);
        worldX = (precipice ? precipice.end : worldX) + 50;
        groundY = getTerrainHeight(worldX);
      }

      if (action === 'stay') {
        return { worldX, y: groundY - 138, w: 72, h: 22, type: 'drone', action: 'stay' };
      }

      const typeRoll = Math.random();
      if (typeRoll < 0.34) {
        return { worldX, y: groundY - 30, w: 28, h: 30, type: 'bug', action: 'jump' };
      }
      if (typeRoll < 0.67) {
        return { worldX, y: groundY - 52, w: 36, h: 52, type: 'server', action: 'jump' };
      }
      return { worldX, y: groundY - 24, w: 62, h: 24, type: 'laser', action: 'jump' };
    }

    function pickRandomAction() {
      return Math.random() < 0.24 ? 'stay' : 'jump';
    }

    function getSpawnDelayMs(previousAction, nextAction) {
      const moveSpeed = baseSpeed * speedMult;
      const baselineFrames = Math.round(23 + Math.random() * 35);
      const randomGapPx = baselineFrames * moveSpeed;
      const minGapPx = getMinGapPx(previousAction, nextAction);
      const maxGapPx = minGapPx + moveSpeed * (16 + Math.random() * 18);
      const gapPx = Math.max(minGapPx, Math.min(randomGapPx, maxGapPx));
      return (gapPx / moveSpeed) * (1000 / 60);
    }

    function getMinGapPx(previousAction, nextAction) {
      const moveSpeed = baseSpeed * speedMult;
      const prevKey = previousAction || 'start';
      const requiredFrames = transitionFrameBudget[prevKey][nextAction];
      return requiredFrames * moveSpeed;
    }

    function canTransition(previousAction, nextAction, gapPx) {
      return gapPx >= getMinGapPx(previousAction, nextAction);
    }

    function hasNearbyObstacle(worldStart, worldEnd, ignoreObstacle = null) {
      return obstacles.some((placed) => {
        if (ignoreObstacle && placed === ignoreObstacle) return false;
        const placedStart = placed.worldX - courseSafety.obstacleSpacingBuffer;
        const placedEnd = placed.worldX + placed.w + courseSafety.obstacleSpacingBuffer;
        return worldStart < placedEnd && worldEnd > placedStart;
      });
    }

    function isObstaclePlacementWinnable(obstacle, action) {
      const obstacleStart = obstacle.worldX;
      const obstacleEnd = obstacle.worldX + obstacle.w;
      const obstacleCenter = obstacleStart + obstacle.w * 0.5;

      if (hasNearbyObstacle(obstacleStart, obstacleEnd, obstacle)) {
        return false;
      }

      if (getPrecipiceNear(obstacleStart, courseSafety.precipiceAvoidanceBuffer) || getPrecipiceNear(obstacleEnd, courseSafety.precipiceAvoidanceBuffer)) {
        return false;
      }

      const adjacentPrecipice = terrain.precipices.find((drop) => (
        obstacleStart >= drop.end && obstacleStart - drop.end < courseSafety.minLandingBuffer
      ) || (
        obstacleEnd <= drop.start && drop.start - obstacleEnd < courseSafety.minTakeoffBuffer
      ));
      if (adjacentPrecipice) {
        return false;
      }

      for (let sampleX = obstacleStart; sampleX <= obstacleEnd; sampleX += courseSafety.clearanceSampleStep) {
        const groundY = getTerrainHeight(sampleX);
        const caveCeilingY = getCaveCeilingAt(sampleX);

        if (caveCeilingY != null) {
          const headroom = groundY - caveCeilingY;
          if (headroom < courseSafety.minCaveHeadroomForAnyObstacle) {
            return false;
          }
          if (action === 'jump' && headroom < courseSafety.minCaveHeadroomForJumpObstacle) {
            return false;
          }
        }

        if (hasNearbyObstacle(sampleX - 8, sampleX + 8, obstacle) && caveCeilingY != null) {
          const localHeadroom = groundY - caveCeilingY;
          if (localHeadroom < courseSafety.minCaveHeadroom + 10) {
            return false;
          }
        }
      }

      const centerGroundY = getTerrainHeight(obstacleCenter);
      const centerCaveCeilingY = getCaveCeilingAt(obstacleCenter);
      if (centerCaveCeilingY != null) {
        const centerHeadroom = centerGroundY - centerCaveCeilingY;
        if (centerHeadroom < courseSafety.minCaveHeadroom) {
          return false;
        }
      }

      return true;
    }

    function scheduleNextObstacle() {
      const moveSpeed = baseSpeed * speedMult;
      const rightMostObstacle = obstacles.reduce((maxX, ob) => Math.max(maxX, ob.worldX + ob.w), worldOffset + canvas.width + 20);

      for (let attempt = 0; attempt < 24; attempt++) {
        const nextAction = pickRandomAction();
        const candidateDelay = getSpawnDelayMs(lastSpawnAction, nextAction);
        const candidateGapPx = candidateDelay * moveSpeed * (60 / 1000);

        if (!canTransition(lastSpawnAction, nextAction, candidateGapPx)) {
          continue;
        }

        const previewAction = spawnActions[Math.floor(Math.random() * spawnActions.length)];
        const previewDelay = getSpawnDelayMs(nextAction, previewAction);
        const previewGapPx = previewDelay * moveSpeed * (60 / 1000);
        if (!canTransition(nextAction, previewAction, previewGapPx)) {
          continue;
        }

        const obstacleWorldX = rightMostObstacle + candidateGapPx;
        const obstacle = createObstacle(nextAction, obstacleWorldX);
        if (!isObstaclePlacementWinnable(obstacle, nextAction)) {
          continue;
        }

        obstacles.push(obstacle);
        lastSpawnAction = nextAction;
        spawnTimer = candidateDelay;
        return;
      }

      const fallbackAction = 'jump';
      const fallbackGapPx = getMinGapPx(lastSpawnAction, fallbackAction) + moveSpeed * 8;
      const obstacleWorldX = rightMostObstacle + fallbackGapPx;
      const fallbackObstacle = createObstacle(fallbackAction, obstacleWorldX);
      if (isObstaclePlacementWinnable(fallbackObstacle, fallbackAction)) {
        obstacles.push(fallbackObstacle);
        lastSpawnAction = fallbackAction;
      }
      spawnTimer = (fallbackGapPx / moveSpeed) * (1000 / 60);
    }

    function drawSkyline() {
      sceneryOffset += (baseSpeed * speedMult) * 0.3;

      for (let i = 0; i < 6; i++) {
        const width = 130;
        const x = (i * 170) - (sceneryOffset % 170);
        const h = 110 + (i % 3) * 30;
        ctx.fillStyle = 'rgba(141,89,255,0.22)';
        ctx.fillRect(x, baseGroundY - h, width, h);

        ctx.fillStyle = 'rgba(46,248,255,0.6)';
        for (let wy = baseGroundY - h + 12; wy < baseGroundY - 10; wy += 20) {
          for (let wx = x + 12; wx < x + width - 10; wx += 22) {
            ctx.fillRect(wx, wy, 8, 9);
          }
        }
      }

      ctx.fillStyle = 'rgba(255,255,255,0.7)';
      for (let i = 0; i < 45; i++) {
        const starX = (i * 41 + 17) % canvas.width;
        const starY = (i * 29 + 23) % (baseGroundY - 130);
        ctx.fillRect((starX + sceneryOffset * 0.12) % canvas.width, starY, 2, 2);
      }
    }

    function drawGround() {
      groundOffset += baseSpeed * speedMult;
      const renderWorldOffset = Math.floor(worldOffset);
      const startWorld = renderWorldOffset - terrain.step;
      const endWorld = renderWorldOffset + canvas.width + terrain.step * 2;
      const groundSampleStep = 6;
      ensureTerrainAhead(endWorld + 300);

      ctx.fillStyle = '#16233f';
      ctx.beginPath();
      ctx.moveTo(0, canvas.height);
      for (let sx = -terrain.step; sx <= canvas.width + terrain.step; sx += groundSampleStep) {
        const worldX = renderWorldOffset + sx;
        const gy = Math.round(getTerrainHeight(worldX));
        ctx.lineTo(sx, gy);
      }
      ctx.lineTo(canvas.width, canvas.height);
      ctx.closePath();
      ctx.fill();

      for (let x = -(groundOffset % 42); x < canvas.width; x += 42) {
        const gy = getTerrainHeight(worldOffset + x + 8);
        if (gy >= canvas.height - 4) continue;
        ctx.fillStyle = 'rgba(46,248,255,0.7)';
        ctx.fillRect(x, gy + 20, 24, 4);
      }

      ctx.fillStyle = 'rgba(12, 26, 48, 0.9)';
      terrain.caves.forEach((cave) => {
        if (cave.end < worldOffset - 40 || cave.start > worldOffset + canvas.width + 40) return;
        const startX = Math.round(cave.start - renderWorldOffset);
        const endX = Math.round(cave.end - renderWorldOffset);
        ctx.beginPath();
        ctx.moveTo(startX, 0);
        ctx.lineTo(startX, cave.baseCeiling);
        for (let sx = startX; sx <= endX; sx += 16) {
          const worldX = renderWorldOffset + sx;
          const wave = Math.sin((worldX * 0.04) + cave.phase) * cave.amplitude;
          ctx.lineTo(sx, cave.baseCeiling + wave);
        }
        ctx.lineTo(endX, 0);
        ctx.closePath();
        ctx.fill();
      });

    }

    function drawPlayer() {
      const g = ctx.createLinearGradient(player.x, player.y, player.x + player.w, player.y + player.h);
      g.addColorStop(0, '#2ef8ff');
      g.addColorStop(1, '#8e5cff');
      ctx.fillStyle = g;
      roundRect(ctx, player.x, player.y, player.w, player.h, 10);
      ctx.fill();

      ctx.fillStyle = '#e9f6ff';
      ctx.font = 'bold 15px monospace';
      ctx.fillText('</>', player.x + 7, player.y + 34);
    }

    function drawObstacle(ob) {
      if (ob.type === 'bug') {
        ctx.font = '28px serif';
        ctx.fillText('üêû', ob.x, ob.y + ob.h);
      } else if (ob.type === 'server') {
        ctx.fillStyle = '#ff5a7c';
        roundRect(ctx, ob.x, ob.y, ob.w, ob.h, 7);
        ctx.fill();
        ctx.fillStyle = '#12020a';
        ctx.fillRect(ob.x + 8, ob.y + 12, ob.w - 16, 6);
        ctx.fillRect(ob.x + 8, ob.y + 26, ob.w - 16, 6);
      } else if (ob.type === 'drone') {
        ctx.fillStyle = 'rgba(255, 202, 95, 0.9)';
        roundRect(ctx, ob.x, ob.y, ob.w, ob.h, 8);
        ctx.fill();
        ctx.fillStyle = '#3e2b09';
        ctx.fillRect(ob.x + 10, ob.y + 8, ob.w - 20, 6);
        ctx.fillStyle = '#ffd95c';
        ctx.fillRect(ob.x + 30, ob.y + ob.h, 12, 12);
      } else {
        const lg = ctx.createLinearGradient(ob.x, ob.y, ob.x, ob.y + ob.h);
        lg.addColorStop(0, 'rgba(255,83,112,0.95)');
        lg.addColorStop(1, 'rgba(255,83,112,0.25)');
        ctx.fillStyle = lg;
        ctx.fillRect(ob.x, ob.y, ob.w, ob.h);
      }
    }

    function roundRect(ctx, x, y, w, h, r) {
      ctx.beginPath();
      ctx.moveTo(x + r, y);
      ctx.arcTo(x + w, y, x + w, y + h, r);
      ctx.arcTo(x + w, y + h, x, y + h, r);
      ctx.arcTo(x, y + h, x, y, r);
      ctx.arcTo(x, y, x + w, y, r);
      ctx.closePath();
    }

    function resetGame() {
      score = 0;
      speedMult = 1;
      baseSpeed = 4.2;
      gameOver = false;
      spawnTimer = 0;
      obstacles.length = 0;
      lastSpawnAction = null;
      worldOffset = 0;
      initTerrain();
      const spawnGround = getTerrainHeight(player.x + player.w * 0.5) || baseGroundY;
      player.y = spawnGround - player.h;
      player.vy = 0;
      player.onGround = true;
      player.jumpsLeft = 2;
      updateHud();
      requestAnimationFrame(loop);
    }

    function updateHud() {
      scoreEl.textContent = Math.floor(score);
      speedEl.textContent = speedMult.toFixed(1);
      bestEl.textContent = Math.floor(best);
    }

    let lastSpawnAction = null;

    function update() {
      if (gameOver) return;

      score += 0.2 * speedMult;
      speedMult = Math.min(4, 1 + score / 340);

      const moveSpeed = baseSpeed * speedMult;
      worldOffset += moveSpeed;
      ensureTerrainAhead(worldOffset + canvas.width + 460);

      player.vy += gravity;
      player.y += player.vy;

      const playerWorldCenter = worldOffset + player.x + player.w * 0.5;
      const currentGround = getTerrainHeight(playerWorldCenter);
      if (isInPrecipice(playerWorldCenter)) {
        player.onGround = false;
        if (player.y + player.h >= currentGround) {
          gameOver = true;
        }
      } else if (player.y >= currentGround - player.h) {
        player.y = currentGround - player.h;
        player.vy = 0;
        player.onGround = true;
        player.jumpsLeft = 2;
      } else {
        player.onGround = false;
      }

      const activeCave = getCaveAt(playerWorldCenter);
      if (activeCave) {
        const ceilingWave = Math.sin((playerWorldCenter * 0.04) + activeCave.phase) * activeCave.amplitude;
        const ceilingY = activeCave.baseCeiling + ceilingWave;
        if (player.y <= ceilingY) {
          gameOver = true;
        }
      }

      if (player.y > canvas.height + 80) {
        gameOver = true;
      }

      spawnTimer -= 16.7;
      if (spawnTimer <= 0) {
        scheduleNextObstacle();
      }

      for (let i = obstacles.length - 1; i >= 0; i--) {
        const ob = obstacles[i];
        const obScreenX = ob.worldX - worldOffset;

        const hit = player.x < obScreenX + ob.w &&
                    player.x + player.w > obScreenX &&
                    player.y < ob.y + ob.h &&
                    player.y + player.h > ob.y;

        if (hit) {
          gameOver = true;
          best = Math.max(best, score);
          localStorage.setItem('techFlowRunnerBest', String(Math.floor(best)));
          updateHud();
          return;
        }

        if (obScreenX + ob.w < -20) {
          obstacles.splice(i, 1);
        }
      }

      if (gameOver) {
        best = Math.max(best, score);
        localStorage.setItem('techFlowRunnerBest', String(Math.floor(best)));
      }

      updateHud();
    }

    function drawGameOver() {
      ctx.fillStyle = 'rgba(3, 7, 18, 0.74)';
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      ctx.fillStyle = '#fff';
      ctx.textAlign = 'center';
      ctx.font = '700 44px Segoe UI';
      ctx.fillText('Signal Lost', canvas.width / 2, canvas.height / 2 - 28);
      ctx.font = '600 24px Segoe UI';
      ctx.fillText(`Distance: ${Math.floor(score)}m`, canvas.width / 2, canvas.height / 2 + 12);
      ctx.font = '500 18px Segoe UI';
      ctx.fillText('Press R to reboot run', canvas.width / 2, canvas.height / 2 + 48);
      ctx.textAlign = 'left';
    }

    function render() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      drawSkyline();
      drawGround();
      drawPlayer();
      obstacles.forEach((ob) => {
        const screenObstacle = { ...ob, x: ob.worldX - worldOffset };
        drawObstacle(screenObstacle);
      });
      if (gameOver) drawGameOver();
    }

    function loop() {
      update();
      render();
      if (!gameOver) requestAnimationFrame(loop);
    }

    function jump() {
      if (gameOver || player.jumpsLeft <= 0) return;
      player.vy = player.jumpPower;
      player.onGround = false;
      player.jumpsLeft -= 1;
    }

    window.addEventListener('keydown', (e) => {
      const key = e.key.toLowerCase();
      if (key === ' ' || key === 'arrowup' || key === 'w') {
        e.preventDefault();
        jump();
      }
      if (gameOver && key === 'r') {
        resetGame();
      }
    });

    canvas.addEventListener('pointerdown', jump);

    initTerrain();
    const initialGround = getTerrainHeight(player.x + player.w * 0.5) || baseGroundY;
    player.y = initialGround - player.h;

    updateHud();
    requestAnimationFrame(loop);
  </script>
</body>
</html>
